[{"content":"附加说明 点击跳转\n","date":"2025-06-20T14:37:14+08:00","permalink":"https://xuexcy.github.io/post/%E9%99%84%E5%8A%A0-%E7%BF%BB%E8%AF%91recursivemacroswithc-20__va_opt__/","title":"附加-翻译RecursiveMacrosWithC++20__VA_OPT__"},{"content":"使用 https 从 github clone 仓库 在 https://github.com/settings/tokens 生成一个新 token 执行 git clone https://github.com/${user_name}/${repository_name}.git 并输入密码时，将密码输入成刚刚生成的 token vscode + clangd 插件 + cmake 配置代码提示 在 CMakeListst.txt 中添加 set(CMAKE_EXPORT_COMPILE_COMMANDS ON) clangd 插件的 Arguments 中添加 --compile-commands-dir=${workspaceFolder}/build Fallback Flags 中添加 --std=c++23 参考: https://github.com/xuexcy/cpp_cmake_project_template ","date":"2025-06-12T18:32:28+08:00","permalink":"https://xuexcy.github.io/post/%E5%B0%8F%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/","title":"小问题集合"},{"content":"文中链接跳转失效时，请移步至github 使用表达式模板做向量计算查阅\n使用表达式模板做向量计算 1. 问题: 向量计算 1 2 3 4 5 static constexpr size_t N{1000}; using StdArray = std::array\u0026lt;double, N\u0026gt;; StdArray a; StdArray b; // 计算 1.2 * a + a * b 并将结果存入 StdArray c 2. 方案分析 2.1 表达式计算 2.1.1 代码实现 ./test_array/calculation_deps.h calculate_by_expression\n1 2 3 4 StdArray c; for (auto i = 0; i \u0026lt; a.size(); ++i) { c[i] = 1.2 * a[i] + a[i] * b[i]; } 2.1.2 执行步骤 double result_1 = 1.2 * a[i]: 读取 a[i]: 读取 N 个 double 计算 1.2 * a[i]: 计算 N 个乘法 double result_ 2= a[i] * b[i]: 读取 a[i]、b[i]: 读取 2N 个 double（ 在前面计算 1.2 * a[i] 时已经读取了 a[i]，这个值应该已经在缓存中了，不过这里我们还是当成一次读取） 计算 a[i] * b[i]: 计算 N 个乘法 double result_3 = result_1 + result_2: 计算 result_1 + result_2: 计算 N 个加法 c[i] = result_3;: 读取 c[i]: 读取 N 个 double 将 result_3 写入 c[i]: 写入 N 个 double 2.1.3. 开销 在每轮循环中创建 result_1、result_2、result_3，使用后立刻销毁(开销可忽略不计) 读取 4000 = 3N = N + 2N + N 个 double 写入 1000 = N 个 double 写入 计算: 乘法 2000 = 2N; 加法 1000 = N 2.2 操作符重载 2.2.1 代码实现 ./array/operator.h namespace array_operator_overload\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 namespace array_operator_overload { StdArray operator+(const StdArray\u0026amp; a, const StdArray\u0026amp; b) { Array result; for (auto i = 0; i \u0026lt; a.size(); ++i) { result[i] = a[i] + b[i]; } return result; } StdArray operator*(const StdArray\u0026amp; a, const StdArray\u0026amp; b) { Array result; for (auto i = 0; i \u0026lt; a.size(); ++i) { result[i] = a[i] * b[i]; } return result; } } // namespace array_operator_overload 2.2.2 使用方法 1 2 3 #include \u0026#34;array/operator.h\u0026#34; using namespace array_operator_overload; StdArray c = 1.2 * a + a * b; 2.2.3 执行步骤 StdArray result_1 = 1.2 * a;: 即 operator*\u0026lt;double, StdArray\u0026gt;(1.2, a) 创建临时变量 StdArray result_1: 创建 N 个 double 读取 a: 读取 N 个 double 计算 1.2 * a[i]: 计算 N 个乘法 将计算结果写入 result_1: 写入 N 个 double StdArray result_2 = a * b;: 即 operator*\u0026lt;StdArray, StdArray\u0026gt;(a, b) 创建临时变量 StdArray result_2: 创建 N 个 double 读取 a、b: 读取 2 * N 个 double 计算 a[i] * b[i]: 计算 N 个乘法 计算结果写入 result_2: 写入 N 个 double StdArray result_3 = result1 + result_2;: 即 operator+\u0026lt;StdArray, StdArray\u0026gt;(result_1, result_2) 创建临时变量 StdArray result_3: 创建 N 个 double 读取 result_1、result_2: 读取 2 * N 个 double 计算 result_1[i] + result_2[i]: 计算 N 个加法 计算结果写入 result_3: 写入 N 个 double StdArray c = {return result_3;};: 如果编译器支持 copy elision, 应该没有开销 2.2.4 开销 先后创建 3 个临时变量 StdArray result_1, result_2, result_3: 创建 3 * N 个 double 读取 5000 = 5N = N + 2 * N + 2 * N 个 double 写入 3000 = 3N 个 double 计算: 乘法 2000 = 2N; 加法 1000 = N 2.3 表达式模板(expression template; ET) 2.3.1 代码实现 ./array/expression_template/expression.h namespace array_expression_template\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // array/expression_template/expression.h namespace array_expression_template { struct Expression {}; // Expression /** item_type: 数据类型，本文中就是 double */ template \u0026lt;class T\u0026gt; struct Variable : public Expression { const item_type\u0026amp; operator[](size_t) const { return t_; } const T t_; }; // Variable, 存储常量 T template \u0026lt;ArrayLike T\u0026gt; struct Array : public Expression { const item_type\u0026amp; operator[](size_t idx) const { return t_[idx]; } const T\u0026amp; t_; }; // Array, 存储向量引用(可以是 std::array/std::vector 或者自定义的符合 concept ArrayLike 的自定义 类型) template \u0026lt;IsExpr LExpr, IsExpr RExpr\u0026gt; struct BinaryExpression : public Expression { const LExpr l_expr_; const RExpr l_expr_; }; // BinaryExpression, 存储二元操作符的左右两个表达式 template \u0026lt;IsExpr LExpr, IsExpr RExpr\u0026gt; struct Add : public BinaryExpression\u0026lt;LExpr, RExpr\u0026gt; { item_type operator[](size_t idx) const { return l_expr_[idx] + r_expr_[idx]; } }; // Add template \u0026lt;IsExpr LExpr, IsExpr RExpr\u0026gt; struct Multiply : public BinaryExpression\u0026lt;LExpr, RExpr\u0026gt; { item_type operator[](size_t idx) const { return l_expr_[idx] * r_expr_[idx]; } }; // Multiply // array/expression_template/operator.h template \u0026lt;IsExpr LExr, IsExpr RExpr\u0026gt; auto operator+(const LExpr l_expr, const RExpr r_expr) { return Add(l_expr, r_expr); } template \u0026lt;IsExpr LExr, IsExpr RExpr\u0026gt; auto operator*(const LExpr l_expr, const RExpr r_expr) { return Multiply(l_expr, r_expr); } // more operator overload for Variable and Array // ... } // namespace array_expression_template 2.3.2 使用方法 1 2 3 4 5 6 #include \u0026#34;array/expression_template/expression.h\u0026#34; using namespace array_expression_template; Array arr_a(a), arr_b(b); auto expr = 1.2 * arr_a + arr_a * arr_b; StdArray c; collect_result(expr, \u0026amp;c); 2.3.3 执行步骤 auto expr_1 = 1.2 * arr_a;: 即 operator*\u0026lt;double, Array\u0026gt;(1.2, arr_a) 创建临时变量 expr_1: 具体类型 Multiply\u0026lt;Variable\u0026lt;double\u0026gt;, Array\u0026lt;StdArray\u0026gt;\u0026gt; auto expr_2 = arr_a * arr_b;: 即 operator*\u0026lt;Array, Array\u0026gt;(arr_a, arr_b) 创建临时变量 expr_2: 具体类型 Multiply\u0026lt;Array\u0026lt;StdArray\u0026gt;, Array\u0026lt;StdArray\u0026gt;\u0026gt; auto expr = expr_1 + expr_2;: 即 operator+\u0026lt;decltype(expr_1), decltype(expr_2)\u0026gt;(expr_1, expr_2) 创建变量 expr: 具体类型 1 2 3 4 Add\u0026lt; Multiply\u0026lt;Variable\u0026lt;double\u0026gt;, Array\u0026lt;StdArray\u0026gt;\u0026gt;, Multiply\u0026lt;Array\u0026lt;StdArray\u0026gt;, Array\u0026lt;StdArray\u0026gt;\u0026gt; \u0026gt; collect_result(expr, \u0026amp;c): 像表达式计算一样进行计算1.2 * a[i] + a[i] * b[i] 并将结果赋值给 c[i] 2.3.4 开销 我们创建了一些表达式对象 两个 Array: 即 Array arr_a(a), arr_b(b); auto expr: 根据前面描述的 expr 的具体类型，一共创建了 1 个 Add，2 个 Multiply，3 个 Array，1 个 Variable，共 7 个表达式对象（Instance of class Expression） 在 collect_result 中，我们通过 operator[] 从表达式中取值，此时 operator[] 中的 l_expr_ 和 r_expr_ 继续调用对应表达式的 operator[]，直到从 Variable 和 Array 返回具体的数值，此时表达式对象一共调用了 7 次重载的 operator[] 3. 方案对比 3.1 对比分析 表达式 1.2 * a + a * b 中一共有 1 个常量、3 个 StdArray 和 3 个操作符。\n现定义如下变量 x : 表达式中的常量个数 y : 表达式中 StdArray 的个数 z : 表达式中的操作符个数 其中 x + y = z + 1\n表达式方案： y: 读取 2 次 a，1 次 b z: 计算 2 次乘法，1 次加法 1: 写入 1 次结果到 StdArray c 操作符重载方案： y: 读取 2 次 a，1 次 b z: 计算 2 次乘法，1 次加法 z: 调用 3 次重载函数 z - 1: 生成 2 个最终会被调回的临时对象（最后一个临时变量会通过 copy elision 赋值给我们想要的结果 StdArray c） z - 1: 读取 2 次临时对象: 除了最后一次重载函数调用，其他的每次重载函数调用的结果都会写入一个临时对象，而这个临时对象一定会再下一个函数调用中读取 z: 写入 3 次结果到 StdArray ET 方案： y: 读取 2 次 a，1 次 b z: 计算 2 次乘法，1 次加法 x: 生成 1 个 Variable 对象 y: 生成 3 个 Array 对象 z: 生成 3 个 BinaryExpression 对象 z: 调用 3 次 BinaryExpression 的 operator[] 重载函数 y: 调用 3 次 Array 的 operator[] 重载函数 x: 调用 1 次 Variable 的 operator[] 重载函数 写入 1 次结果到 StdArray c 表达式方案 操作符重载方案 ET 方案 读取已有的 StdArray 次数 y y y 数值计算次数 z z z 写入 StdArray 次数 1 z 1 生成最终可以被销毁的对象个数 0 z - 1 x + y + z 写入最在可被销毁的对象的次数 0 z - 1 0 重载函数调用次数 0 z x + y + z 3.2 对比测试 测试使用的表达式更复杂(不是1.2 * a + a * b)\n相关代码与结果 test: test_array/calculation_test.cc benchmark: 代码 test_array/calculation_benchmark.cc 机器信息 结果 expression_template_array_benchmark.txt profile: 代码 test_array/calculation_profile.cc 结果 expression_template_array_profile_g++.svg 结果分析 表达式方案最优(看 benchmark 和 profile 结果)，因为直接从 StdArray 取值并计算表达式，没有函数其他函数调用、较大的临时变量生成等问题，另外，可能还有编译期优化计算。该方案中调用 std::array operator[] 耗时占比也比较大 操作符重载和 ET 方案都有较多的函数调用(看 profile 结果) ET 方案主要耗时在调用函数 operator[](看 profile 结果)，生成表达式耗时并不怎么耗时(看 benchmark 结果) 4. ET 方案说明 4.1 方案说明 lazy evaluation(惰性计算、延时计算): 一开始只是生成了表达式的实例(Add\u0026lt;Multiply, Multiply\u0026gt; expr)，并没有将结果正真的计算出来，等到 collect_result 时才开始遍历计算 4.2 在实现过程中用到的优化手段 对 size() 和 operator[] 使用 inline 关键字 在 class BinaryExpression 中存储 size，而不是每次在调用 size() 时根据 l_expr_ 和 r_expr_ 去判断(像其构造函数中的 assert 那样) 使用 class Add 继承 class BinaryExpression，而不是将 AddOperator 当成 BinaryExpression 的一个模板参数，因为这样会多一次 operator() 函数调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // bad template \u0026lt;IsExpr LExpr, IsExpr RExpr, class Op\u0026gt; requires SameItem\u0026lt;LExpr, RExpr\u0026gt; class BinaryExpression : public Expression { public: item_type operator[](size_t idx) inline { return Op(l_expr_[idx], r_expr_[idx]); } } template \u0026lt;class T\u0026gt; struct AddOperator { static T operator()(const T\u0026amp; lhs, const T\u0026amp; rhs) { return lhs + rhs; } }; template \u0026lt;class LExpr, class RExpr\u0026gt; using Add = Binary\u0026lt;LExpr, RExpr, AddOperator\u0026lt;LExpr::item_type\u0026gt;::operator\u0026gt;; 5. 参考 https://zhuanlan.zhihu.com/p/701819779 https://zhuanlan.zhihu.com/p/416276856 https://www.cnblogs.com/chengxuyuancc/p/3238469.html https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Expression-template ","date":"2025-05-16T22:31:29+08:00","permalink":"https://xuexcy.github.io/post/%E4%BD%BF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E6%9D%BF%E5%81%9A%E5%90%91%E9%87%8F%E8%AE%A1%E7%AE%97/","title":"使用表达式模板做向量计算"},{"content":"软件安装 在 mac os 上安装 brew install gperftools 在 CMakeLists.txt 中链接 profiler 假设程序为：calculation_profile.cc 1 2 3 set(LIB_PROFILER_DIR \u0026#34;/opt/homebrew/Cellar/gperftools/2.16/lib\u0026#34;) set(CMAKE_EXE_LINKER_FLAGS \u0026#34;${CMAKE_EXE_LINKER_FLAGS} -L${LIB_PROFILER_DIR} -lprofiler -ltcmalloc\u0026#34;) add_executable(expression_template_array_profile calculation_profile.cc) 执行 profiler 1 2 3 4 5 6 7 8 9 10 11 bin_name=expression_template_array_profile prof_file=$bin_name.prof text_file=$bin_name.txt svg_file=$bin_name.svg # 生成 prof 文件 env CPUPROFILE=$prof_file $bin_name # 输出文本和 svg 图片 pprof $bin_path $prof_file --text \u0026gt; $text_file pprof $bin_path $prof_file --svg \u0026gt; $svg_file TODO 火焰图\n其他 遇到问题 otool-classic: can't open file: /usr/lib/system/libXXXXX，好像可以不用管，不影响结果。 refs: # otool-classic unable to find /usr/lib libraries on MacOS https://forums.developer.apple.com/forums/thread/722360 ","date":"2025-04-18T16:38:34+08:00","permalink":"https://xuexcy.github.io/post/gperftools-cpu%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","title":"gperftools-cpu性能分析"},{"content":"[TOC]\n翻译: Recursive macros with C++20 __VA_OPT__ 水平有限,欢迎指正,谢谢! 多平台发布内容不一致时，以 github 更新为主 个人添加的一些注解可能有些啰嗦,大部分都是在反反复复解释不同的宏是如何展开了,主要是为了记录自己理解原文内容过程中的一些思考,各位阅读时可以跳过. 译者前言 标题: 使用 C++20 的 __VA_OPT__ 实现递归宏\n原文信息:\n作者: David Mazières 日期: 2021/06 译文信息:\n作者: 薛成韵(xuechengyun) 日期: 2025/03/26 邮箱: xuechengyunxue@gmail.com 1433094974@qq.com github 地址: link 文中一些名词与解释:\npreprocessor: 预处理器,文中提到的 C/C++ pre-preprocessor, cpp 都翻译成预处理器 variable-argument macro: 可变参数宏, 如 #define PRINT(...) print(__VA_ARGS__) macro type: 宏类型 object-like macro: 类对象宏,如 #define OL 123 function-like macro: 类函数宏,如 #define FL(x) ((x)+1) macro name: 宏名字,如 OL,FL macro parameters: 宏参数,如 x substitution list: 替换列表,宏名字和参数后的那部分,如 123,((x)+1), 另外，替换列表可以为空, 比如 #define EMPTY 1 2 3 4 5 6 7 8 using Str = std::string; struct Macro { Str name; enum class Type { ObjectLike, FunctionLike }; Type type; std::vector\u0026lt;Str\u0026gt; parameters; Str sl; // substitution list }; // struct Macro replacing bit: 替换位,后文简称为 rb. 一个宏对应一个 bit, 当一个宏发生了替换后就会将对应的 bit 置为 true，后续将会处理替换产生的新结果.在读取到替换结果之后的一个字符时，该 bit 会被重置为 false. FL(x)+FL(y) : 当 FL(x) 替换成 ((x) + 1) 后, FL 的 replacing bit 会被置为 true, 将替换结果 ((x) + 1) 继续处理完后, 会读取 FL(x) 后面的加号 +，在读取 + 前会将 FL 的 replacing bit 重置为 false unavailable bit: 不可用位(或者叫不可扩展位吧), 后文简称为 ub. 标记某个 token 是否能被扩展,一个 token 对应一个 bit. token: 一种符号,如 FL,123, x,+,1,(, );两个值相同的字符串可能是同一个 token，也可能是不同的 token 参数和替换列表中对应的 token 是同一个 token，可以认为是同一个字符串的引用. 当 token 在参数中不能展开时，替换到替换列表后依然不能展开.\n1 2 3 4 #define ADD(a, b) a + b #define DOUBLE(c) ADD(c, c) #define ADD_FIVE(d) ADD(d, FIVE) #define FIVE 5 假设此时 FIVE 不能被展开\nDOUBLE(FIVE)\n展开 DOUBLE(FIVE) 得到 ADD(FIVE, FIVE)，此时 ADD 的两个参数 a: FIVE 和 b: FIVE 是同一个 token，也就是 DOUBLE 的参数 c: FIVE 这个 token 展开得到 ADD(FIVE, FIVE) 得到 FIVE + FIVE, 此时这两个 FIVE 分别对应 ADD 的参数 a: FIVE, b: FIVE, 而上一步已知 a: FIVE 和 b: FIVE 是同一个 token, 于是 FIVE + FIVE 中的两个 FIVE 也还是同一个 token ADD_FIVE(FIVE)\n展开 ADD_FIVE(FIVE) 得到 ADD(FIVE, FIVE), 此时这两个参数 a: FIVE 和 b: FIVE 不是同一个 token, 其中 a: FIVE 是 ADD_FIVE 的参数 d: FIVE, b: FIVE 是 ADD_FIVE 的替换列表中的 FIVE 展开 ADD(FIVE, FIVE) 得到 FIVE + FIVE, 此时这两个 FIVE 分别对应 ADD 的参数 a: FIVE, b: FIVE, 而上一步已知 a: FIVE 和 b: FIVE 不是同一个 token, 于是 FIVE + FIVE 中的两个 FIVE 就不是同一个 token 注意:\n文中存在一些圆括号(),一些是原文已有的,一些是译者额外加的.译者加的圆括号中,里面的内容可能是原文英文,形如\u0026quot;译文(原文)\u0026quot;,也有可能是译文,形如\u0026quot;原文(译文)\u0026quot;,比如 \u0026ldquo;pre-processor(预处理)、类对象宏(object-like macros).另外还可能添加了一些注释. 标有\u0026quot;xuechengyun 注\u0026quot;的地方都是个人对原文的一些理解、解释或附加说明,主要是为了更方便的理解原文 参考:\n知乎: 聊一聊新的宏__VA_OPT__ Introduction(引言) 如果能在 c++ 中定义可以被优雅打印的枚举岂不是很好? 在 C++20 中,你可以定义一个宏,这个宏可以同时创建一个枚举类型和定义一个将枚举值转换成字符串的函数.样例如下:\n1 2 3 4 5 6 7 8 9 10 11 12 MAKE_ENUM(MYType, ZERO, ONE, TWO, THREE); void test(MyType e) { std::cout \u0026lt;\u0026lt; to_cstring(e) \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; std::endl; } int main() { test(ZERO); test(ONE); test(TWO); test(THREE); } OUTPUT:\n1 2 3 4 ZERO = 0 ONE = 1 TWO = 2 THREE = 3 实现上述功能的关键是 C++20 中的一个新的 pre-processor(预处理器)特性 __VA_OPT__(x).当 variable-argument marco(可变参数宏)的参数个数非 0 时,它可以展开成 x,否则什么也不做.该特性正是实现递归宏中基本情况所需的,它可以做一些事情,比如让 FOR_EACH 将它的每一个参数都填充到另一个宏中.下面是如何使用 FOR_EACH 定义 MAKE_ENUM:\nxuechengyun 注:\nFOR_EACH(PRINT, a, b, c) 可以扩展为\n1 2 3 PRINT(a) PRINT(b) PRINT(c) 这样就可以通过宏 PRINT 输出所有参数.\n1 2 3 4 5 6 7 8 9 10 11 12 #define ENUM_CASE(name) case name: return #name; #define MAKE_ENUM(type, ...) \\ enum type { __VA_ARGS__ }; \\ constexpr const char* to_cstring(type _e) { \\ using enum type; \\ switch (_e) { \\ FOR_EACH(ENUM_CASE, __VA_ARGS__) \\ default: \\ return \u0026#34;unknown\u0026#34;; \\ } \\ } 完整代码见 make_enum.cc.本博客余下部分将会讲解如何通过一种简单且普遍的方法来定义 FOR_EACH.虽然参数列表的大小有一个(任意的)限制,但是该限制随着代码长度增大呈指数级增长.加上 5 行额外的代码,接受的参数就可以超过 300 个,如此数量看起来已经很多了.另外相较于旧方法中,为每种可能数量的参数都各自定义一个宏来说,这种方法更容易被接受.\n在这个博客中,我将讲解 C/C++ 中的宏是如何运作的;接着展示如何将宏和 C++20 中的 __VA__OPT__ 结合起来做一些牛逼的事.\nC macro overview (概述 C 语言中的宏) C 和 C++ 支持两种类型的宏,一种是没有参数的类对象宏(object-like macros),一种是有参数的类函数宏(function-like macros).下面是例子.\n1 2 #define OL 123 // object-like macro 类对象宏 #define FL(x) ((x)+1) // function-like macro 类函数宏 宏的主体被称为替换列表(substitution list),即宏名字和可选参数后面部分.如上单个 token 123 是 OL 的替换列表,token 列表 ((x)+1) 是 FL 的替换列表.\n宏扩展发生在 C/C++ 预处理器(缩写 cpp, 即 C/C++ preprocess,后文简称\u0026quot;预处理器\u0026rdquo;,以免和 c++ 程序语言混淆)将程序源代码转换为一系列词法标记(lexical tokens)之后.标识符(identifiers)(例如 FL),数字(numbers),字符字面量(character literals), 字符串(quoted strings),圆括号(parentheses, (, ) ),还有操作符(例如 + ) 都是 token 示例.预处理器通过将很多 tokens 原样复制,有效地将输入 tokens 列表转换为输出 tokens, 并在适当的地方将宏展开.\n预处理器旨在保证源代码的预处理一定会终止(termination).个人认为在编程语言中 termination 被看得过重了(被高估了, overrated).我的意思是,C 语言明确的知道一个微不足道的 cpptorture.c 程序的编译需要超过100年的时间和数艾字节(exabytes, EB, 1EB = 1024PB=2^60B)的内存,但知道这一事实又有什么可欣慰的呢?有些离题了.实际上,人们喜欢编写像 linux \u0026lt;sys/epoll.h\u0026gt; 头文件这样的代码：\nxuechengyun 注:\n在 cpptorture.c 中的代码用了 64 行形如如下的宏定义来计算 $x * 2^{64}$.\n1 2 3 4 5 #define X1(x) X2(x)+X2(x)` ... #define X30(x) X31(x)+X32(x) ... #define X64(x) x+x 提前说明一下,一次宏的处理分为三步(后面我们还会继续提到这三步):\n处理参数(对参数中的宏也会进行处理) 将处理后的参数替换(replace)到宏的替换列表(substitution list)中 将替换后的结果作为新的输入重新处理. 其中前两步和宏的定义相关,第 1 步和宏的参数个数相关,第 2 步和宏的替换列表相关.但是第 3 步是处理宏替换后产生的新结果,它的处理不依赖于当前这个宏的定义.\n假设调用 X1(3) 来计算 $3 * 2^{64}$,那么:\nX64(3) 展开需要 [ $(2^1 - 1)$ 次替换 ],得到 3+3,也就是使用 [ $(2^1 -1)$ 个加号 ] 将 [ $2^1$ 个 3 ] 相加\nX63(3) 展开需要 [ $1$ 次替换 + X64(3)展开两次 ] = [ $1$ 次替换 + $(2^2-2)$ 次替换 ] = [ $(2^2 - 1)$ 次替换 ],得到 3+3+3+3,也就是使用 [ $(2^2 -1)$ 个加号 ] 将 [ $(2^2)$ 个 3 ] 相加\nX62(3) 展开需要 [ $1$ 次替换 + X63(3) 展开两次 ] = [ $1$ 次替换 + $(2^3-2)$ 次替换 ] = [ $(2^3 - 1)$ 次替换 ],得到 3+3+3+3+3+3+3+3,也就是使用 [ $(2^3 -1)$ 个加号 ] 将 [ $(2^3)$ 个 3 ] 相加\nX61(3) 展开需要 [ $1$ 次替换 + X62(3) 展开两次 ] = [ $1$ 次替换 + $(2^4-2)$ 次替换 ] = [ $(2^4 - 1)$ 次替换 ],得到 3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3,也就是使用 [ $(2^4 -1)$ 个加号 ] 将 [ $(2^4)$ 个 3 ] 相加\n\u0026hellip;\nX1(3) 展开需要 [ $1$ 次替换 + X2(3) 展开两次 ] = [ $1$ 次替换 + $(2^{64}-2)$ 次替换 ] = [ $(2^{64} - 1)$ 次替换 ],得到 [ $(2^{64} - 1)$ 个加号 ] 将 [ $(2^{64})$ 个 3 ] 相加\n最终我们调用 X1(3) 展开后的代码需要的字节数就是数字 3 和加号操作符 + 的个数之和个字节,即 $(2^{65}-1)B$ = $(2^5 * 2^{60} - 1)B$ = $32EB - 1B$.也就是文中说的编译需要数艾字节的内存(many exabytes of memory).\n最终 X1(3) 展开需要 $2^{64} - 1$ 次替换(也就是 + 的个数).假设一次替换需要 1 纳秒($1\\ ns=10^{-9}\\ s$), 且 $2^{10} \\approx 10^3$,那么 $2^{64}-1\\ ns\\approx 2^4 \\times 10^{18}\\ ns = 16 \\times 10^9\\ s=16\\times10^{9}\\div60\\div60\\div24\\div365\\ 年\\approx507 年$.也就是文中说的编译需要超过 100 年的时间(over 100 years).\n注意,这里我们说的一次替换的时间包含了预处理器读取 token、参数列表、扩展参数列表、替换 substitution list 所需的时间,比如预处理器读取 X1、(3)、将 3 扩展成 3、替换参数扩展结果 3 到替换列表中得到 X2(3) + X2(3).然后预处理器又重新扫描了这个结果并进行处理,此时除了对两个 X2(3) 进行了“替换”,还多耗读取了两个空格和一个加号,不过在上面的计算中就不细究了.\n1 2 3 4 5 6 7 8 9 enum EPOLL_EVENTS { EPOLLIN = 0x001, #define EPOLLIN EPOLLIN EPOLLIN = 0x002, #define EPOLLPRI EPOLLPRI EPOLLOUT = 0x004, #define EPOLLOUT EPOLOUTL /* ... */ }; 将 EPOLL_EVENTS 定义成一个枚举挺好的,因为这样有助于调试,而且更优雅.对于程序来说,能够使用 #ifdef EPOLLPRI 来检查特定标志的可用性也很好.所以,利用 C/C++ 预处理器通常不会递归展开宏的事实,\u0026lt;sys/epoll.h\u0026gt; 头文件将这两个问题都解决了.如此定义 enum EPOLL_EVENT ,token EPOLLIN 就会扩展一次成为 EPOLLIN 后停止扩展, 所以它实际上等价于支持 #ifdef 的 enum.\nxuechengyun 注:\n\u0026lt;sys/epoll.h\u0026gt; 首先将 EPOLL_EVENTS 定义成了枚举类型,这样更方便调试,代码看起来也舒服.另外,为了使用 #ifdef EPOLLPRI 来检查这个 flag 是否被设置,在 enum EPOLL_EVENTS 中又定义了和枚举值名称相同的宏,如 #define EPOLLINE EPOLLIN,这样使用起来更方便.\n这种实现方式的前提是预处理器不会递归展开宏.如果可以递归展开,那么预处理器可以认为 #define EPOLLIN EPOLLIN 中的第二个 EPOLLIN (即宏的主体、替换列表)依然是一个宏,然后继续展开.那宏展开就会无法终止(termination)\n为了防止宏递归展开,预处理器将每个定义的宏关联到一个 bit.该 bit 反映了宏当前是否被它的替换列表(substitution list)替换了,在此我们称之为 replacing bit(替换位).预处理器又将输入流(input stream)中的每一个 token 和一个 bit 关联起来,表明这个 token 不能进行宏扩展(macro-expanded),在此我们称之为 unavailable bit(不可用位).一开始 replacing 和 unavailable bits 都被清空为 false 了.\nxuechengyun 注:\n每个宏关联一个 bit,叫 replacing bit,后文提到的 rb, macro_rb 即此含义\n每个 token 关联一个 bit,叫 unavailable bit,后文提到的 ub, token_ub 即此含义\n1 2 3 std::unordered_set\u0026lt;Str, Macro\u0026gt; name_to_macro; std::unordered_map\u0026lt;Str, bool\u0026gt; macro_name_to_rb; std::unordered_map\u0026lt;Token, bool\u0026gt; token_to_ub; 当预处理器处理每个输入 token T 时,它会设置 T 的 unavailable bit,并按如下流程决定是否对 T 进行宏展开:\n如果 T 是一个 replacing bit 被置为 true 的宏的名字,预处理器就会将其 unavailable bit 也置为 true.注意,即使 T 在一个不可以被宏展开的上下文中 (因为 T 可能是一个类函数宏,但是后面没有 ( 跟着,所以它没有办法被展开)(xuechengyun 注: 后文中有一个 #define PARENS () 宏就是让 T 后面没有 (,以阻止 T 展开),预处理器依然会设置其 unavailable bit.另外,一旦 unavailable bit 被置为 true,就再也不会被重置为 false.\nxuechengyun 注:\ntoken_ub 被置为 true 后就无法重置为 false\n1 2 3 4 // T 是一个宏名字 + rb 为 true if (auto it = macro_name_to_rb.find(T.str()); it != macro_name_to_rb.end() \u0026amp;\u0026amp; it-\u0026gt;second) { token_to_ub[T] = true; } 如果 T 是一个类对象宏的名字,并且 T 的 unavailable bit 是 false,那么就将 T 展开.\nxuechengyun 注:\n1 2 3 4 5 6 7 // T 是一个类对象宏名字 + ub 为 false if (auto it = name_to_macro.find(T); it != name_to_macro.end() \u0026amp;\u0026amp; Macro::Type::ObjectLike == it-\u0026gt;second.type \u0026amp;\u0026amp; !token_to_ub[T]) { expand_macro(T) } 如果 T 是一个类函数宏的名字,且 T 的 unavailable bit 是 false,且 T 后面跟随了 (,那么就将 T 展开.注意,如果调用 T 使用的参数数量不对,那么程序就有问题(xuechengyun 注: 假设 #define T(a, b) a + b 那么 T(), T(1), T(1, 2, 3) 就是有问题的程序).\nxuechengyun 注:\n1 2 3 4 5 6 7 8 9 10 // T 是一个类函数宏名字 + ub 为 false + 名字后面有括号 \u0026#39;(\u0026#39; if (auto it = name_to_macro.find(T); it != name_to_macro.end() \u0026amp;\u0026amp; Macro::Type::FunctionLike == it-\u0026gt;second.type \u0026amp;\u0026amp; !token_to_ub[T] \u0026amp;\u0026amp; \u0026#39;(\u0026#39; == next_char_of(T)) { args = scan_arguments(); assert(args.size() == it-\u0026gt;second.parameters.size()); expand_macro(T, args); } 如果预处理器决定不对 T 进行宏扩展,那么它就直接将 T 添加到当前的输出 token 列表.反之,通过如下两个阶段扩展 T:\n当 T 是一个类函数宏时,预处理器扫描所有给 T 的参数,并在这些参数上进行宏扩展.它像处理普通的 token 一样扫描参数,但是不将输出的 tokens 放到主处理器中输出中,而是为 T 的每个参数构建一个替换 token 列表(replacement token list).同时记录原始的、非宏展开的参数,以便和 # 和 ## 一起使用.\nxuechengyun 注:\n1 2 3 4 #define A(x) (x*x) #define B(x, y) x+y // 如下是输入列表 B(A(3),B)(4,5)+B(6,7) 首先, B 是一个类函数宏,扫描到参数 A(3), B;然后在参数 A(3) 、B 分别进行扩展,得到 (3*3) 和 B;接着为 B 的每个参数构建一个 replacement tokens list,也就是((3*3), B)\n预处理器拿到 T 的替换列表后,如果 T 有参数,将替换列表中出现的参数名用第 1 步计算出来的对应的参数 token list 替换掉.同时根据替换列表中的 # 和 ## 标识进行字符串化和拼接.然后,在逻辑上将得到的结果 tokens 添加到输入列表中.最后,预处理器将宏 T 的 replacing bit 设置为 true.\nxuechengyun 注:\n预处理器拿到 B 的替换列表 x+y,此时发现 B 有两个参数 (x, y),就用第一步计算出的 replacement token list ((3*3), B) 替换 B 的替换列表中的对应部分,即将 x 替换成 (3*3),将 y 替换成 B,最终得到 (3*3)+B. 然后,将这个结果添加到输入列表中,即得到 (3*3)+B(4,5)+B(6,7).最后,将 B 的 replacing bit 设置为 true.\n当 replacing bit 被设置为 true 后,预处理器继续像往常一样处理输入,这些输入就是刚刚添加到输入列表中的 tokens.这可能导致更多的宏展开,所以有时把它叫做重新扫描阶段(rescan phase).一旦预处理器处理了由替换列表产生的所有 tokens,它就会将 T 的 replacing bit 重置为 false.\nxuechengyun 注:\nB 的 replacing bit 为设置为 true 后,预处理器继续处理刚刚添加到输入列表中的 tokens,也就是 (3*3)+B,当处理到尾部这个 B 时,虽然后续还有 (4,5)+B(6,7) 让 B 可以读取到参数 (4, 5),但是由于 B 的 replacing bit 为 true,所以不对这个尾部的 B 进行展开.于是对第一个对 B 宏替换后的结果重新扫描后并处理后,最终得到了 (3*3)+B.\n此时,预处理器将 B 的替换列表产生的所有 tokens (3*3)+B 都处理完了.到此为止,预处理器将和第一个 B 相关的 tokens 都处理完了,于是将 replacing bit 设置为 false.另外输出列表为 (3*3)+B\n接着预处理器开始处理剩下的 tokens (4,5)+B(6,7) 并输出 (4,5)+6+7.最终输出列表为 (3*3)+B(4,5)+6+7\nxuechengyun 注:\n1 2 3 4 5 6 7 8 9 10 11 12 13 auto args = scan_args_for(T); assert(args.size() == T.parameters.size()); std::vector\u0026lt;std::list\u0026lt;View\u0026gt;\u0026gt; replace_tokens; for (size_t i = 0; i \u0026lt; args.size(); ++i) { // 第 1 步: 对实参进行宏处理 replace_token.emplace_back(process_tokens(arg)); } // 第 2 步: 将 replace_tokens 放到替换表中对应形参名的地方 auto new_sl = T.sl; replace(T.parameters/*from*/, replace_tokens/*to*/, \u0026amp;new_sl); macro_name_to_rb[T] = true; process_tokens(new_sl); // 也就是说在这个 new_sl 中再次遇到 T 的话,是不会再处理展开它的 macro_name_to_rb[T] = false; 我们来看一个简单的例子:\nFL(FL(5)) =\u0026gt; ((((5)+1))+1)\n在第一阶段,外面这个宏 FL 的参数 FL(5) 会被展开为 token list ((5)+1),从而得到 FL(((5)+1)).展开外面 FL 这个宏就是将替换列表中的形参 x 替换成这个实参 ((5)+1),于是得到 ((((5)+1))+1).结果应该还是挺直观的.需要注意的是,由于里面的那个 FL 的展开发生在第一阶段,所以 FL 的 replacing bit 一直都是 false,且没有任何 token 的 unavailable bit 被设置为 true 过.\n现在我们来看一个更有趣的例子:\n1 2 #define ID(arg) arg ID(ID)(ID)(X) // =\u0026gt; ID(ID)(X) 先看 token 序列的第一部分 ID(ID). 我们从第 1 阶段开始,对内部的 ID 进行展开,由于这是一个后面没有 ( 的类函数宏,所以预处理器不会展开它.于是,预处理器将外面这个 ID 的替换列表中的 arg 替换成 ID,然后将这个替换结果放到输入列表(input list)中(xuechengyun 注: 此时整个输入为 ID + (ID)(X),其中前者是第一个 ID 替换后的结果,后者是预处理器还没有开始处理的剩余部分).接着将宏 ID 的 replacing bit 设置为 true 后进入第 2 阶段(重新扫描).在处理当前的第一个 token ID 时,预处理器将它的 unavailable bit 设置为 true(因为 ID 的 replacing bit 是 true) 且不展开它.最后,预处理器将 ID 的 replacing bit 重置为 false,不过,此时已经没有什么需要展开了,因为第三个 ID 后面没有 (.\n实际上规范中存在一个已知的歧义,即究竟何时重置替换位.如果一个宏展开后以一个类函数宏结尾,但是该类函数宏的参数需要从展开部分的后面读取 tokens(xuechengyun 注: 比如我们前面读取到 B(A(3),B)) 并展开后得到了 (3*3)+B, 此时展开后的结果就是以一个类函数宏 B 结尾,这个宏的参数需要从后面的部分 (4,5)+B(6,7) 中读取),那又会发生什么?在实践中,编译器似乎会做一些直观的事,并在完全遵循宏展开后面的第一个 token 前重置 replacing bit.例子如下:\nxuechengyun 注:\n什么叫\u0026quot;在完全遵循宏展开后面的第一个 token\u0026quot;? 以 B(A(3),B)(4,5)+B(6,7) 为例, 当 B(A(3),B) 处理完后紧跟的第一个 token 就是 (4,5)+B(6,7) 的第一个字符,也就是 (,也就是在处理 ( 前将 B 的 replacing bit 重置,这样 B(6,7) 才可以展开.\n1 2 3 4 5 6 7 #define LPAREN ( #define ID2(arg) arg ID(ID2)(ID)(X) // =\u0026gt; X ID(ID2 LPAREN)ID)(X) // =\u0026gt; X ID(ID2 LPAREN ID))(X) // =\u0026gt; ID(X) ID(ID2 (ID))(X) // =\u0026gt; ID(X) 在上面的例子中,不同位置的 (ID) 成为 ID2 的参数后, 都被移动到了第一个 ID 的参数中,并且你可以看到,当第二个 ID 一旦被移动到第一个 ID 的替换列表中,就会立刻将 ID 的 unavailable bit 设置为 true.\nxuechengyun 注:\n当第一个 ID 的替换完成后就会将其 rb 置为 true,而 rb 为 true 后就会立刻将替换结果中的 ID 的 ub 置为 true. 上面说的 ID 成为 ID2 的参数指的是第 3、4 种情况.\nxuechengyun 注:\n当读取到一个 token 是宏名字,并确定要展开后,执行以下 3 步:\n读取宏的参数并展开,得到 expanded_arguments 使用 expanded_arguments 替换宏的替换列表(substitution list),替换后的结果为 new_input. 将 token 的 replacing bit 设置为 true 继续处理 new_input, 这些 new_input 又可能产生 new_new_input, 反正等它们都处理完后,在将一开始的那个 token 的 replacing bit 重置为 false 我们将这 3 步分为两个部分:\n宏定义相关: 前两步为一个部分,执行过程和宏的定义相关.比如,第 1 步依赖宏的参数个数,如果读取的参数数量和宏定义的参数数量不一致,那么程序就是 ill-formed 的.第 2 步依赖于宏的替换表. 宏定义无关: 第 3 步是处理宏展开后的结果,即得到的 new_input,在处理 new_input 的过程当中并不依赖于原来那个宏的定义.只是在遇到原来那个宏时,不再对其进行展开(识别到 replacing bit 为 true). 简单来说就是参数替换后,如果替换的结果(new_input)中又有这个宏名字,那么在处理 new_input 时(rescan phase)就不会在展开这个宏,比如 ID(ID)X -\u0026gt; ID(X), new_input = ID,那就不处理它.当这些结果处理完后就会重置 replacing bit,之后再遇到同名字的宏还是需要展开. 比如 ID(ID)ID(X) -\u0026gt; ID + ID(X) -\u0026gt; ID + X -\u0026gt; IDX\nRecursive macros(递归宏) 当然,C 预处理器可以通过 #include 指令简单的实现地递归.文件可以 include 自己, 并适当地定义/取消定义常量(#undef/#define constants),然后通过 #if 条件来实现基本情况.虽然通过递归 include-file 的方式并不那么实用,但你确实可以递归地展开宏,至少可以相互递归展开.我第一次见到 Paul Fultz 提出的一个小技巧,是通过将 token 一直隐藏到另一个宏执行完重新扫描过程,来避免在要展开的宏上设置 unavailable bit.\nxuechengyun 注:\n如下就是通过 [文件 #include 自己] + [#undef/#define 常量] + [#if 条件] 来实现递归宏.目的是通过宏 RESULT 来计算 $N$ 的阶乘.我们来看一下 4 的阶乘怎么算:\n定义 $N = 4, 即 #define N 4,用户使用宏 RESULT 需要 #include \u0026quot;factorial.h\u0026quot; #include \u0026quot;factorial.h\u0026quot; 首先得到 N = 4; RESULT = 1 进入 #if N \u0026gt; 0, 得到 TEMP = N = 4, TEMP_RESULT = RESULT * N = 1 * 4 = 4 然后 #undef N #define N (TEMP - 1) 得到 N = TEMP - 1 = 3,同理得到 RESULT=TEMP_RESULT=4 接着 #include \u0026quot;factorial.h\u0026quot; 后开始重复第 2 ~ 4 步: 递归第一次: N = 3; RESULT = 4 -\u0026gt; N = 2; RESULT = 12 递归第二次: N = 2; RESULT = 12 -\u0026gt; N = 1; RESULT = 24 递归第三次: N = 1; RESULT = 24 -\u0026gt; N = 0; RESULT = 24 递归第四次: N = 0; RESULT = 24 -\u0026gt; #if N \u0026gt; 0 为 false -\u0026gt; 终止程序 最终, RESULT = 24, 即 4 的阶乘为 24 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // factorial.h #ifndef N #define N 5 // 初始值 #endif #ifndef RESULT #define RESULT 1 // 初始结果 #endif #if N \u0026gt; 0 #define TEMP N #define TEMP_RESULT (RESULT * N) #undef N #define N (TEMP - 1) #undef RESULT #define RESULT TEMP_RESULT #include \u0026#34;factorial.h\u0026#34; #endif 我们来看一个例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #define ID(arg) arg #define PARENS () // 注意 () 前的空格,也就是这是一个类对象宏 #define F_AGAIN() F #define F() f F_AGAIN PARENS() // F() -\u0026gt; f F_AGAIN PARENS() // 重新扫描 F 的替换结果 // f F_AGAIN PARENS() -\u0026gt; f F_AGAIN ()() F() // =\u0026gt; f F_AGAIN ()() // ID(F()) -\u0026gt; (...) -\u0026gt; ID(f F_AGAIN ()()) -\u0026gt; f F_AGAIN ()() // 此时 \u0026#34;ID(F())\u0026#34; 的参数展开和替换列表替换已经完成,也就是我们前面提到的\u0026#34;宏定义相关\u0026#34;部分 // 重新扫描 ID 的替换结果, 对 \u0026#34;F_AGAIN ()\u0026#34; 进行替换 // f F_AGAIN ()() -\u0026gt; f F() // 重新扫描 F_AGAIN 的替换结果, 对 \u0026#34;F()\u0026#34; 进行替换 // f F() -\u0026gt; f f F_AGAIN PARENS() // 重新扫描 F 的替换结果, 对 \u0026#34;PARENS\u0026#34; 进行替换 // f f F_AGAIN ()() ID(F()) // =\u0026gt; f f F_AGAIN ()() // ID(ID(F())) -\u0026gt; (...) -\u0026gt; ID(f f F_AGAIN ()()) -\u0026gt; f f F_AGAIN ()() // 此时 ID(ID(F())) 的参数展开和替换列表替换已经完成,也就是我们前面提到的\u0026#34;宏定义相关\u0026#34;部分 // 重新扫描 ID 的替换结果, 对 \u0026#34;F_AGAIN ()\u0026#34; 进行替换 // f f F_AGAIN ()() -\u0026gt; f f F() // 重新扫描 F_AGAIN 的替换结果,对 \u0026#34;F()\u0026#34; 进行替换 // f f F() -\u0026gt; f f f F_AGAIN PARENS() // 重新扫描 F() 的替换结果,对 \u0026#34;PARENS\u0026#34; 进行替换 // f f f F_AGAIN PARENS() -\u0026gt; f f f F_AGAIN() ID(ID(F())) // =\u0026gt; f f f F_AGAIN ()() 当 F() 展开后, 注意 F_AGAIN 后面没有 ( (xuechengyun 注: F_AGAIN 后面是 PARENS,此时 PARENS 还没有展开成 ()),所以它不会被当成宏进行展开.当然,在下一步 PARENS 被展开成了 (),但此时预处理器已经将 F_AGAIN 这个 token 输出了, 所以决定此时再展开它(指 F_AGAIN)已经太晚了.因此, F() 的输出(也就是 f F_AGAIN ()())可能包含一个没有展开的宏调用,但是所有 tokens 的 unavailable bit 都是 false.\nxuechengyun 注:\n在某个宏 T 发生替换后其 rb 被设置为 true,当重新扫描替换结果又遇到了 T 才会将其 ub 设置为 true.\n这里我们的目的是让 F 和 F_AGAIN 相互递归调用,并避免 ub 被设置为 true.如果 #define F() f F_AGAIN ()() ,那么当 F 发生替换后重新扫描时,又会对 F_AGAIN 进行替换并得到 F,在对 F_AGAIN 的替换结果重新扫描时就会将 F 的 ub 设置为 true.\n为了阻止 ub 为设置为 false,我们只需要在对 F 的替换结果重新扫描时阻止 F_AGAIN 展开,因为如果 F_AGAIN 展开就会再次遇到 F,F 的 ub 就会被设置为 true.阻止类函数宏展开的方法就是让其后面没有 (.另外,为了实现递归调用,我们又需要为 F_AGAIN 后面添加一个 (.\nPARENS 这个技巧的原理就是:\n当预处理器重新扫描 F 的替换结果并遇到 F_AGAIN 时,让其后面没有 ( 以至于无法展开,通过终止递归调用来避免将 F 的 ub 设置为 true. 当预处理器扫描到 F_AGAIN 后面时,通过其后面的宏 PARENS 展开为其添加一个 (,如果还存在下一次扫描(比如在外层添加一个 ID 就会重新扫描一遍),由 PARENS 展开来的 () 又能让 F_AGAIN 继续递归展开. 最终, PARENS 提供了一个让 F 在宏替换后就终止递归调用,使用 ID 又能继续递归调用的能力.同时也避免了 F 的 ub 被设置为 true.\n现在来看看当我们调用 ID(F()) 时发生了什么.首先我们将参数 F() 展开成 f F_AGAIN ()().这就完成了对宏 F 的处理,所以我们将 F 的 replacing bit 重置.接着,将 ID 的替换列表中的 arg (也叫做单 token arg) 替换成 f F_AGAIN ()(). 接着,预处理器将 ID 的 replacing bit 设置为 true 并重新扫描(rescan) f F_AGAIN ()(),如此导至 F_AGAIN 和 F 先后被展开.当然,再次使用 PARENS 这种技巧依然可以阻止第二个 F_AGAIN 被展开.\n每当我们将 F() 传递给标识宏(identity macro, 也就是展开成宏的参数自身) ID 时,它就会多展开一次.即使我们不能无限递归,我们还是可以设置一个任意的最大递归次数(xuechengyun 注: 就是不断的在外层添加 ID, 添加多少个就可以递归调用多少次).当我们简单地生成一些和我们写的代码行数呈指数级增长的宏调用时(还记得我们的 trivial cpptoture.c program 吗?),真正的限制是我们能给预处理器提供多少时间和内存,而不是预处理器不是图灵完备的事实.如下 5 行代码重新扫描了 342 次(EXPAND4 被调用了 256 次,当然中间的宏也会导致重新扫描)\n1 2 3 4 5 #define EXPAND(arg) EXPAND1(EXPAND1(EXPAND1(EXPAND1(arg)))) #define EXPAND1(arg) EXPAND2(EXPAND2(EXPAND2(EXPAND2(arg)))) #define EXPAND2(arg) EXPAND3(EXPAND3(EXPAND3(EXPAND3(arg)))) #define EXPAND3(arg) EXPAND4(EXPAND4(EXPAND4(EXPAND4(arg)))) #define EXPAND4(arg) arg xuechengyun 注:\n1 个 arg 作为初始参数被 scan 1 次\n1 个 EXPAND(arg) 替换得到 4 个 EXPAND1 并 re-scan 1 次\n4 个 EXPAND1 替换得到 16 个 EXPAND2 并 re-scan 4 次\n16 个 EXPAND2 替换得到 64 个 EXPAND3 并 re-scan 16 次\n64 个 EXPAND3 替换得到 256 个 EXPAND4 并 re-scan 64 次\n256 个 EXPAND4 替换后 re-scan 256 次\n所以 5 行代码扫描了 1 + 1 + 4 + 16 + 64 + 256 = 342 次; 另外, 因为有 256 个 EXPAND4, 所以 EXPAND4 被调用了 256 次.\n不过,256 这个数字并不重要.重要的是代码总共被扫描了多少次,即 342.\n前面提到的标识宏(identity macro) #define ID(arg) arg 的作用就是让 arg 作为参数先展开一次(即 ID(arg)),然后得到结果,结果又被 re-scan 一次. 如果需要这个结果再被展开一次,那就将结果再次包含到标识宏中(即 ID(ID(arg))).\n如此,如果遇到同名且不能展开的宏, 即 replacing bit 被置为 1 的宏,就用 ID 再包一层,此时其 replacing bit 就会被重置,展开结果也会作为外一层的 ID 的参数被重新扫描.为了重新扫描多次,我们可以多包几层 ID 宏, 比如包 $N = 7$ 层,那就是 #define EXPAND(arg) ID(ID(ID(ID(ID(ID(ID(arg))))))), 这样我们就可以扫描 $N+1=8$ 次.\n文中 EXPAND 的实现就是将在外层添加 ID 宏(也就是 EXPAND4 宏)的效率呈指数级增长.也就是说你不嫌麻烦,完全可以将 $N$ 设置成 341,然后像下面这样做:\n1 2 3 4 5 6 7 8 // 其中有 341 个 `ID` #define EXPAND(arg) ID(ID(ID(ID( ....(arg).... )))) // 或者像 cpptorture.c 那样 #define EXPAND1(arg) EXPAND2(arg) #define EXPAND2(arg) EXPAND3(arg) ... #define EXPAND340(arg) EXPAND341(arg) #define EXPAND341(arg) arg Variable-argument macros(可变参数宏) C++11 添加了可变参数宏.当使用 #define 定义宏,如果最后一个宏参数是 ... 而不是一个标识符(identifier)时,它可以接受任意数量的参数,替换列表中特殊的 token __VA_ARGS__ 会被扩展成所有的这些参数,参数间用都好分隔(commas).一个典型的例子如下:\n#define LOG(...) printf(__VA_ARGS__)\n不幸的是,在很多场景中都存在一个小小的恼人的事,那就是当 ... 表示 0 个参数时,很难编写一个能够正确生成 C 代码的宏.例如,假设你想要使用一个宏在括号里打印信息.你可能会尝试做如下的事:\n1 2 #define LOG(fmt, ...) printf(\u0026#34;[\u0026#34; fmt \u0026#34;]\u0026#34;, __VA_ARGS__) LOG(\u0026#34;level %d\u0026#34;, lvl); // =\u0026gt; printf(\u0026#34;[\u0026#34; \u0026#34;level %d\u0026#34; \u0026#34;]\u0026#34;, lvl); 这里我们利用了 C 语言连接相邻字符串常量的事实.由于 LOG 的第一个参数 (对应于参数 fmt)预计是一个字符串常量,因此我们可以为 printf 构造一个新的格式化参数,其中,这个字符串被括起来了.不幸的是,如果在格式化字符串后面没有参数,那就无法起作用:\n1 LOG(\u0026#34;hello\u0026#34;) // =\u0026gt; printf(\u0026#34;[\u0026#34; \u0026#34;hello\u0026#34; \u0026#34;]\u0026#34;, ); printf(\u0026quot;hello\u0026quot;,) 中多余的逗号在 C 和 C++ 语言中是一种语法错误.C++20 通过添加一个新的特殊标识符 __VA_OPT__ 来解决这个问题.这个序列 __VA_OPT__(x) 只能用在可变参数宏的替换列表中,如果 __VA_ARGS__ 非空 __VA_OPT__(x) 就会展开成 x,否则展开后就什么都没有了.这让我们可以通过在参数列表为空时抑制逗号来修复宏 LOG 的问题.\n1 2 #define LOG(fmt, ...) printf(\u0026#34;[\u0026#34; fmt \u0026#34;]\u0026#34; __VA_OPT__(,) __VA_ARGS__) LOG(\u0026#34;hello\u0026#34;); // =\u0026gt; printf(\u0026#34;[\u0026#34; \u0026#34;hello\u0026#34; \u0026#34;]\u0026#34;); 自然,一个意想不到的好处就是,区分空参和非空参列表正是我们要实现递归的基本情况所需要的机制.\nThe FOR_EACH macro(FOR_EACH 宏) 现在我们有了实现 FOR_EACH 宏所需的所有部分:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #define PARENS () #define EXPAND(...) EXPAND4(EXPAND4(EXPAND4(EXPAND4(__VA_ARGS__)))) #define EXPAND4(...) EXPAND3(EXPAND3(EXPAND3(EXPAND3(__VA_ARGS__)))) #define EXPAND3(...) EXPAND2(EXPAND2(EXPAND2(EXPAND2(__VA_ARGS__)))) #define EXPAND2(...) EXPAND1(EXPAND1(EXPAND1(EXPAND1(__VA_ARGS__)))) #define EXPAND1(...) __VA_ARGS__ #define FOR_EACH(macro, ...) \\ __VA_OPT__(EXPAND(FOR_EACH_HELPER(macro, __VA_ARGS__))) #define FOR_EACH_HELPER(macro, a1, ...) \\ macro(a1) \\ __VA_OPT__(FOR_EACH_AGAIN PARENS (macro, __VA_ARGS__)) #define FOR_EACH_AGAIN() FOR_EACH_HELPER FOR_EACH(F, a, b, c, 1, 2, 3) // =\u0026gt; F(a) F(b) F(c) F(1) F(2) F(3) xuechengyun 注:\n这里的 FOR_EACH 的第一个参数 macro 是一个参数数量为 1 的类函数宏，文章最后我会给出一种让 macro 可以是接受任意参数数量的实现方法\n注意,我们已经调整了 EXPAND 的写法,这样就可以通过简单地使用 __VA_ARGS__ 而不是一个叫做 arg 的来处理输出逗号的宏.\nxuechengyun 注：\n也就是使用了 ... 和 __VA_ARGS__ 将 EXPAND 实现成了可变参数宏\n如果不使用可变参数 ...,而是使用 arg,那么如果实参展开后有逗号的话,就会出现参数数量不符的情况,比如:\n1 2 3 4 5 6 7 8 9 10 11 #define REVERSE(a, b) b, a, REVERSE_AGAIN PARENS #define REVERSE_AGAIN() REVERSE // 这里我们使用 arg 而不是 ... #define EXPAND(arg) EXPAND1(EXPAND1(arg)) #define EXPAND1(arg) arg // 我们预期得到 b, a, d, c, f, e EXPAND(REVERSE(a, b)(c, d)(e, f)) // 1. 处理 EXPAND 的参数,得到参数展开的结果为 \u0026#34;b, a, REVERSE_AGAIN ()(c, d)(e, f)\u0026#34; // 2. 将参数展开结果替换到 EXPAND 的替换列表,得到 \u0026#34;EXPAND1(EXPAND1(b, a, REVERSE_AGAIN()(c, d)(e, f)))\u0026#34; // 3. 处理第一个 EXPAND1 的参数,即扩展 \u0026#34;EXPAND1(b, a, REVERSE_AGAIN()(c, d)(e, f))\u0026#34;,此时读取第二个 EXPAND1 的参数时,就会发现参数数量不对,输入中有三个参数 \u0026#34;b\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;REVERSE_AGAIN()(c, d)(e, f)\u0026#34;,但实际上 EXPAND1 只接受一个参数. // 于是预处理器就会报错,这也就是为什么我们要使用 ... 而不是 arg 的原因 大部分工作发生在 FOR_EACH_HELPER(macro, a1, ...) 中,它将参数 a1 应用到 macro 中,如果剩余的参数不是空的,就接着使用 __VA_OPT__ 来进行递归.和前一节一样,它也使用了 PARENS 这个技巧来实现递归.唯一美中不足的是我们必须要一直重新扫描宏,这就是为什么 FOR_EACH 宏要将 FOR_EACH_HELPER 嵌在 EXPAND 中的原因.另外,FOR_EACH 也使用了 __VA_OPTS__ 来处理空参数的情况.\nxuechengyun 注:\nFOR_EACH 需要将 ... 代表的每一个参数都依次放到 macro 的参数列表中，所以需要一直扫描以便获取下一个参数 a，而可以一直扫描的前提就是将需要扫描的部分放到 EXPAND 中, 也就是 FOR_EACH_HELPER 部分.\n美中不足的是,在我们可能只需要扫描三五次就可以结束时,EXPAND 依然会强制扫描 342 次.比如 EXPAND(3),我们知道其实只需要扫描 1 次就已经得到了最终结果 3,但是它还是会先替换为 EXPAND4(EXPAND4(EXPAND4(EXPAND4(3)))),接着继续重新扫描,最终扫描 342 次得到 3.\n我会在生产环境的代码中使用这个东西吗?我在思考这个问题.在我首个 10 年 C++ 编程生涯中,我曾经认为成为一名优秀的 C++ 程序员就是要展示你有多聪明.现在作为一名睿智的资深教员,我知道成为一名优秀的 C++ 程序员就是要表现出克制.你需要知道 如何 以及 何时 展示聪明才智.所以,让我们从一些可选方法开始进行成本-效益分析:\n你可以手动维护单独的枚举声明和 pretty-print/scanner 函数,但这样可能存在不同步的风险.\n你可以用另一个程序生成一个 C++ 代码,但是这样会使构建过程变得复杂,并且不会让代码更具可读性.C++ 不是一个生成文本的好语言.如果你使用 perl、python 或 bash,代码不一定对其他 C++ 程序员更透明.\n我正在做的是: 我写了一个和 MAKE_ENUM 等价的宏,这个宏将 __VA_ARGS__ 字符串化,并将它传递给一个大约 25 行的函数,这个函数将这些字符串解析到一个 std::vector\u0026lt;std::string\u0026gt;.接着我使用一个包含了 std::maps 的 EnumTable 类型来获取枚举值和字符串.EnumTab 的构造函数接受一个 std::vector\u0026lt;std::string\u0026gt; 和包含常量的 std::initializer_list.所以基本上我的宏最终在为每个枚举类型生成了一个这样的函数:\n1 2 3 4 5 6 static inline const EnumTab\u0026amp; getEnumTab(const Enum*) { static const EnumTab tab(EnumTab::parse_va_args(#__VA_ARS__), {__VA_ARGS__}); return tab; } 这个代码并未发布,我至今都不想公开展示它的原因之一是,枚举解析(这些枚举需要被读取并写入一个人类可读的文件中)的代码过于粗糙.\n所以我认为 FOR_EACH 这个方法实际上是完胜选项 2 和 3.最克制的选项(在 C++ 中你应该总是考虑这个选项, 克制、克制、再克制) 是第 1 个.\n使用 FOR_EACH 的复杂度是多少?如果你不知道预处理器如何工作,那么理解 FOR_EACH 是如何工作的绝对很棘手.不幸的是,很难弄清楚预处理器是如何工作的.直到我已经理解了预处理器如何工作,我才能够理解 C++ 的 language specification(语言规范) 中宏替换的部分. https://en.cppreference.com 没有涉及到必要的细节.另一方面,我现在有了这篇博客发表,我可以在我的代码中引用它,所以写这篇文章实际上是决定我是否要使用这个技巧的一部分.\nFOR_EACH 也远非我所见过的最粗暴的宏用法.它甚至都没有使用 token 粘贴符(##) 来合成无法被文本搜索的新 tokens.虽然这种实现方式很难理解,但至少代码很短.更重要的是,FOR_EACH 的接口非常直观.对于一个多行的 C 语言宏,我认为 MAKE_ENUM 相当可读.并且一旦你在一个地方使用 FOR_EACH,那么你可以潜在的将复杂性分摊到其他宏的使用上.\n不管你如何权衡,有一点可以肯定: __VA_OPT__ 的引入使得 FOR_EACH 明显比老版本的 C++ 中 brittle(脆弱的) 和 disgusting(恶心的) 的方法更牛逼 plus.\n译者附加说明 ","date":"2025-04-18T16:22:10+08:00","permalink":"https://xuexcy.github.io/post/%E7%BF%BB%E8%AF%91recursivemacroswithc-20__va_opt__/","title":"翻译RecursiveMacrosWithC++20__VA_OPT__"},{"content":"cmake_use_boost 1 2 3 4 5 6 7 . ├── CMakeLists.txt ├── build_and_run.sh ├── main.cc ├── output.txt └── thirdparty └── boost CMakeLists.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 cmake_minimum_required(VERSION 3.28) project(cmake_use_boost) set(CMAKE_CXX_STANDARD 23) set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # 设置三方库存放目录为 项目根目录/thirdparty set(THIRDPARTY_DIR ${CMAKE_SOURCE_DIR}/thirdparty) message(\u0026#34;thirdparty_dir: \u0026#34; ${THIRDPARTY_DIR}) include(FetchContent) # import boost # 设置需要使用的 boost 库 set(BOOST_INCLUDE_LIBRARIES bimap) set(BOOST_ENABLE_CMAKE ON) FetchContent_Declare( boost # boost release 下载地址 URL https://github.com/boostorg/boost/releases/download/boost-1.86.0/boost-1.86.0-cmake.tar.gz DOWNLOAD_EXTRACT_TIMESTAMP ON # 下载后解压到本地的目录 SOURCE_DIR ${THIRDPARTY_DIR}/boost EXCLUDE_FROM_ALL ) FetchContent_MakeAvailable(boost) add_executable(main main.cc) # 链接 boost 库 target_link_libraries(main boost_bimap) main.cc 1 2 3 4 5 6 7 8 #include \u0026#34;boost/bimap.hpp\u0026#34; int main() { using bm_type = boost::bimap\u0026lt;int, std::string\u0026gt; using bm_value_type = bm_type::value_type; bm_type bm; bm.insert(bm_value_type(1, \u0026#34;one\u0026#34;)); return 0; } ","date":"2024-10-29T21:17:03+08:00","permalink":"https://xuexcy.github.io/post/cmake%E5%AF%BC%E5%85%A5boost%E4%BD%BF%E7%94%A8/","title":"cmake导入boost使用"},{"content":"跨平台同步办法 macbook: macbook中 文稿 等同于 ~/Document\n本机: 新建 ~/Document/xuechengyun_sync文件夹 Obsidian: 打开本机 vault 目录~/Document/xuechengyun_sync/Obsidian icloud：设置 icloud 同步 文稿 文件夹 百度云: 同步 ~/Document/xuechengyun_sync文件夹。百度云仅作为备份 安卓:\n本机: 新建 个人/Obsidian 文件夹 Obsidian: 打开本机 vault 目录 个人/Obsidian ipad:\nObsidian: 从 icloud 打开云端 vault 目录 文稿/xuechengyun_sync/Obsidian Obsidian 插件 remotely-save: 各个平台的 Obsidian 安装 remotely-save 插件后开启同步，插件会将本地 vault 目录同步至 one_drive 应用/remotely-save/Obsidian 文件夹\nQ\u0026amp;A Q: 为什么在 macbook 本地新建的文件夹在 ~/Document 下？ A: icloud 只能设置同步\u0026quot;桌面与文稿文件夹\u0026quot; ，也就是 ~/Desktop 和 ~/Document Q: 是否可以设置 one_drive 同步多个不同的 Obsidian vault？ A: 不行。Obsidian 插件 remotely-save 的 Onedrive (个人版) (App Folder）功能，只能读写 /应用/removely-save/Obsidian 目录，所以只能将 vault 同步到这个目录，如果同步多个 vault可能造成文件混乱 ","date":"2024-10-21T23:02:12+08:00","permalink":"https://xuexcy.github.io/post/obsidian%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%90%8C%E6%AD%A5/","title":"Obsidian跨平台同步"},{"content":" ","date":"2024-10-16T14:45:12+08:00","permalink":"https://xuexcy.github.io/life/tiantian/","title":"天天"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://xuexcy.github.io/post/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://xuexcy.github.io/post/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://xuexcy.github.io/post/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://xuexcy.github.io/post/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://xuexcy.github.io/post/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://xuexcy.github.io/post/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://xuexcy.github.io/post/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://xuexcy.github.io/post/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://xuexcy.github.io/post/emoji-support/","title":"Emoji Support"}]